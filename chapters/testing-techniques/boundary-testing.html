
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Boundary testing Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-hints/plugin-hints.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="structural-testing.html" />
    
    
    <link rel="prev" href="specification-based-testing.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../preface/structure.html">
            
                <a href="../preface/structure.html">
            
                    
                    Structure of the book
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../getting-started/">
            
                <a href="../getting-started/">
            
                    
                    Getting started with software testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../getting-started/why-software-testing.html">
            
                <a href="../getting-started/why-software-testing.html">
            
                    
                    Why software testing?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../getting-started/testing-principles.html">
            
                <a href="../getting-started/testing-principles.html">
            
                    
                    Principles of software testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="../getting-started/test-automation.html">
            
                <a href="../getting-started/test-automation.html">
            
                    
                    Software testing automation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="./">
            
                <a href="./">
            
                    
                    Testing techniques
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="3.1.1" data-path="specification-based-testing.html">
            
                <a href="specification-based-testing.html">
            
                    
                    Specification-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.1.2" data-path="boundary-testing.html">
            
                <a href="boundary-testing.html">
            
                    
                    Boundary testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="structural-testing.html">
            
                <a href="structural-testing.html">
            
                    
                    Structural-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="model-based-testing.html">
            
                <a href="model-based-testing.html">
            
                    
                    Model-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="design-by-contracts.html">
            
                <a href="design-by-contracts.html">
            
                    
                    Design-by-contracts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.6" data-path="property-based-testing.html">
            
                <a href="property-based-testing.html">
            
                    
                    Property-based testing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../pragmatic-testing/">
            
                <a href="../pragmatic-testing/">
            
                    
                    Pragmatic software testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../pragmatic-testing/testing-pyramid.html">
            
                <a href="../pragmatic-testing/testing-pyramid.html">
            
                    
                    The testing pyramid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2" data-path="../pragmatic-testing/mock-objects.html">
            
                <a href="../pragmatic-testing/mock-objects.html">
            
                    
                    Mock objects
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3" data-path="../pragmatic-testing/design-for-testability.html">
            
                <a href="../pragmatic-testing/design-for-testability.html">
            
                    
                    Design for testability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4" data-path="../pragmatic-testing/tdd.html">
            
                <a href="../pragmatic-testing/tdd.html">
            
                    
                    Test-driven development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5" data-path="../pragmatic-testing/test-code-quality.html">
            
                <a href="../pragmatic-testing/test-code-quality.html">
            
                    
                    Test code quality and engineering
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../intelligent-testing/">
            
                <a href="../intelligent-testing/">
            
                    
                    Intelligent testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1.1" >
            
                <span>
            
                    
                    Random testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.2" data-path="../intelligent-testing/mutation-testing.html">
            
                <a href="../intelligent-testing/mutation-testing.html">
            
                    
                    Mutation testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.3" data-path="../intelligent-testing/fuzzing.html">
            
                <a href="../intelligent-testing/fuzzing.html">
            
                    
                    Fuzzing testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.4" >
            
                <span>
            
                    
                    Search-based software testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../testing-into-context/">
            
                <a href="../testing-into-context/">
            
                    
                    Testing in the context
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.1.1" data-path="../testing-into-context/web-testing.html">
            
                <a href="../testing-into-context/web-testing.html">
            
                    
                    Web testing (soon)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.2" >
            
                <span>
            
                    
                    Database testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.3" >
            
                <span>
            
                    
                    Mobile testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.4" >
            
                <span>
            
                    
                    Continuous experimentation (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.5" >
            
                <span>
            
                    
                    Embedded software testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="7.1" data-path="../non-functional-testing/">
            
                <a href="../non-functional-testing/">
            
                    
                    Non-functional testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="7.1.1" data-path="../non-functional-testing/security-testing.html">
            
                <a href="../non-functional-testing/security-testing.html">
            
                    
                    Security testing (soon)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="7.1.2" >
            
                <span>
            
                    
                    Performance testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="8.1" >
            
                <span>
            
                    
                    Software Quality
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.1.1" >
            
                <span>
            
                    
                    Code reviews (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="8.1.2" >
            
                <span>
            
                    
                    Code metrics (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="8.1.3" >
            
                <span>
            
                    
                    Ethics and testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Boundary testing</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="boundary-testing">Boundary testing</h1>
<p>Off-by-one mistakes are a common cause for bugs in software systems.
As developers, we have all made mistakes such as using a &quot;greater than&quot; operator (<code>&gt;</code>) where it had to be a &quot;greater than or equal&quot; operator (<code>&gt;=</code>). 
Interestingly, programs with such a bug tend to work well for most of the provided inputs. They fail, however, when the input is &quot;near the boundary of condition&quot;.</p>
<p>In this chapter, we explore <strong>boundary testing</strong> techniques.</p>
<h2 id="boundaries-in-between-classespartitions">Boundaries in between classes/partitions</h2>
<p>In the previous chapter, we studied specification-based techniques and, more specifically,
we understood the concept of classes/partitions.
When we devise classes, these have &quot;close boundaries&quot;
with the other classes. 
In other words, if we keep performing small changes 
to an input that belongs to some partition (e.g., by adding +1 to it), 
at some point this input will now belong to another class. 
The precise point where the input changes from one class to another is what we call a <em>boundary</em>.
And this is precisely what boundary testing is about: to make the program behave correctly
when inputs are near a boundary.</p>
<p>More formally,
we can find such boundaries by finding a pair of consecutive 
input values <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><msub><mi>p</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>p</mi><mn>2</mn></msub><mo>]</mo></mrow><annotation encoding="application/x-tex">[p_1,p_2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span><span class="mclose">]</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">p_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> belongs to partition A, and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">p_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">p</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span></span></span></span> belongs to partition B.</p>
<p>Let us apply boundary testing in a concrete example:</p>
<blockquote>
<p><strong>Requirement: Calculating the number of points of the player</strong></p>
<p>Given the score of the player and the number of remaining lives of the player, the program does the following:</p>
<ul>
<li>If the player&apos;s score is below 50, then it always adds 50 points on top of the current points.</li>
<li>If the player&apos;s score is greater than or equals to 50, then:<ul>
<li>if the number of remaining lives is greater than or equal to 3: it triples the score of the player.</li>
<li>otherwise, it adds 30 points on top of the current points.</li>
</ul>
</li>
</ul>
</blockquote>
<p>A possible implementation for this method can be:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerPoints</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">totalPoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> currentPoints, <span class="hljs-keyword">int</span> remainingLives)</span> </span>{
    <span class="hljs-keyword">if</span>(currentPoints &lt; <span class="hljs-number">50</span>)
      <span class="hljs-keyword">return</span> currentPoints+<span class="hljs-number">50</span>;

    <span class="hljs-keyword">return</span> remainingLives &lt; <span class="hljs-number">3</span> ? currentPoints+<span class="hljs-number">30</span> : currentPoints*<span class="hljs-number">3</span>;
  }
}
</code></pre>
<p>When devising the partitions to test this method, a tester might come up with the following partitions:</p>
<ol>
<li><strong>Less points</strong>: Score &lt; 50</li>
<li><strong>Many points but little lives</strong>: Score &gt;= 50 and remaining lives &lt; 3</li>
<li><strong>Many points and many lives</strong>: Score &gt;= 50 and remaining lives &gt;= 3</li>
</ol>
<p>Those partitions would lead testers to devise at least three test cases, one per partition:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlayerPointsTest</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PlayerPoints pp = <span class="hljs-keyword">new</span> PlayerPoints();

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lessPoints</span><span class="hljs-params">()</span> </span>{
    assertEquals(<span class="hljs-number">30</span>+<span class="hljs-number">50</span>, pp.totalPoints(<span class="hljs-number">30</span>, <span class="hljs-number">5</span>));
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manyPointsButLittleLives</span><span class="hljs-params">()</span> </span>{
    assertEquals(<span class="hljs-number">300</span>+<span class="hljs-number">30</span>, pp.totalPoints(<span class="hljs-number">300</span>, <span class="hljs-number">1</span>));
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">manyPointsAndManyLives</span><span class="hljs-params">()</span> </span>{
    assertEquals(<span class="hljs-number">500</span>*<span class="hljs-number">3</span>, pp.totalPoints(<span class="hljs-number">500</span>, <span class="hljs-number">10</span>));
  }
}
</code></pre>
<p>However, a tester who is aware of boundaries also devises test cases that explore the boundaries of the domain.
Let us explore them: </p>
<ul>
<li><p><strong>Boundary 1:</strong> When the score is strictly smaller than 50, it belongs to partition 1. If the score is greater than or equal to 50, it belongs to partitions 2 and 3. Therefore, we observe the following boundary: when the score changes from 49 to 50, the partition it belongs to also changes (let us call this test B1).</p>
</li>
<li><p><strong>Boundary 2:</strong> Given a score that is greater than or equal to 50, we observe that if the number of remaining lives is smaller than 3, it belongs to partition 2; otherwise, it belongs
to partition 3. Thus, we just identified another boundary there (let us call this test B2).</p>
</li>
</ul>
<p>We can visualise these partitions with their boundaries in a diagram.</p>
<p><img src="img/boundary-testing/examples/partition_boundaries.svg" alt="Partitions with their boundaries"></p>
<p>In our example, the tester would then 
devise and automate test cases B1 and B2. Given that a boundary is composed of two different input values, note that
each boundary will require <em>at least</em> two test cases:</p>
<p>For B1:</p>
<ul>
<li>B1.1 = input={score=49, remaining lives=5}, output={99}</li>
<li>B1.2 = input={score=50, remaining lives=5}, output={100}</li>
</ul>
<p>For B2:</p>
<ul>
<li>B2.1 = input={score 500, remaining lives=3}, output={200}</li>
<li>B2.2 = input={score 500, remaining lives=2}, output={130}</li>
</ul>
<p>In JUnit code (and note how we wrote the two test cases for a boundary in a single test (and not splitting it into two
test methods). That makes the test more cohesive; if
if find a boundary bug, a single test will let us know):</p>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">betweenLessAndManyPoints</span><span class="hljs-params">()</span> </span>{
  assertEquals(<span class="hljs-number">49</span>+<span class="hljs-number">50</span>, pp.totalPoints(<span class="hljs-number">49</span>, <span class="hljs-number">5</span>));
  assertEquals(<span class="hljs-number">50</span>*<span class="hljs-number">3</span>, pp.totalPoints(<span class="hljs-number">50</span>, <span class="hljs-number">5</span>));
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">betweenLessAndManyLives</span><span class="hljs-params">()</span> </span>{
  assertEquals(<span class="hljs-number">500</span>*<span class="hljs-number">3</span>, pp.totalPoints(<span class="hljs-number">500</span>, <span class="hljs-number">3</span>));
  assertEquals(<span class="hljs-number">500</span>+<span class="hljs-number">30</span>, pp.totalPoints(<span class="hljs-number">500</span>, <span class="hljs-number">2</span>));
}
</code></pre>
<p><div class="alert alert-success hints-alert"><div class="hints-icon"><i class="fa fa-mortar-board"></i></div><div class="hints-container"><p>You might have noticed that, for B1, in case of score &lt; 50, <code>remaining lives</code> makes no difference.
However, for score &gt;= 50, <code>remaining lives</code> does make a difference, as the output can vary according to its value. 
And for the B1.2 test case, we chose <code>remaining lives</code> = 5, which makes the
condition true. 
You might wondering whether you also need to devise another test case, B1.3, where the remaining lives condition would be exercised as false. </p>
<p>If you are looking to test all possible combinations, then the answer is yes. However, in longer
conditions, full of boundaries, the number of combinations might be too high, making it unfeasible for the developer
to test them all. Later in this chapter, we will learn
how to choose values for the &quot;boundaries that we do not care about&quot;.</p>
</div></div></p>
<h2 id="on-and-off-points">On and off points</h2>
<p>Given some initial intuition on how to analyse boundaries, let us define some
terminology:</p>
<ul>
<li><strong>On-point:</strong> The on-point is the value that is exactly on the boundary. This is the value we see in the condition itself. </li>
<li><strong>Off-point</strong>: The off-point is the value that is closest to the boundary and that flips the condition. If the on-point makes the condition true, the off point makes it false and vice versa. Note that when dealing with equalities or inequalities (e.g. <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">x = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">=</span><span class="mord mathrm">6</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&#x2260;</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">x \neq 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.716em;"></span><span class="strut bottom" style="height:0.9309999999999999em;vertical-align:-0.215em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">&#x2260;</span><span class="mord mathrm">6</span></span></span></span>), there are two off-points; one in each direction.</li>
<li><strong>In-points</strong>: In-points are all the values that make the condition true.</li>
<li><strong>Out-points</strong>: Out-points are all the values that make the condition false.</li>
</ul>
<p><strong>Example:</strong> Suppose we have a program that adds shipping costs when the total price is below 100.
The condition used in the program is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&lt;</mo><mn>1</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">x &lt; 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">&lt;</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>.</p>
<ul>
<li>The on-point is <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>, as that is the value that is precisely in the condition.</li>
<li>The on-point makes the condition false (100 is not smaller than 100), so the off-point should be the closest number that makes the condition true.
This will be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mn>9</mn></mrow><annotation encoding="application/x-tex">99</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">9</span><span class="mord mathrm">9</span></span></span></span>, as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mn>9</mn><mo>&lt;</mo><mn>1</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">99 &lt; 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">9</span><span class="mord mathrm">9</span><span class="mrel">&lt;</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span> is true.</li>
<li>The in-points are the values which are smaller than or equal to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>9</mn><mn>9</mn></mrow><annotation encoding="application/x-tex">99</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">9</span><span class="mord mathrm">9</span></span></span></span>. For example, 37, 42, 56.</li>
<li>The out-points are all values which are larger than or equal to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>. For example, 325, 1254, 101.</li>
</ul>
<p>We show all these points in the diagram below.</p>
<p><img src="img/boundary-testing/examples/on_off_points.svg" alt="On- and off-points, in- and out-points"></p>
<p>Let us now study a similar but slightly different condition: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&#x2264;</mo><mn>1</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">x \leq 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">&#x2264;</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span> (note how similar they are; the only difference is that, in this one, we use smaller than or equals to):</p>
<ul>
<li>The on-point is still <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>0</mn></mrow><annotation encoding="application/x-tex">100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span>: this is the value that is precisely in the condition.</li>
<li>The condition is evaluated as true for the on-point. So, the off-point should be the closest number to the on-point, but making the condition false. The off-point is thus <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>0</mn><mn>1</mn></mrow><annotation encoding="application/x-tex">101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.64444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span></span></span></span>.</li>
</ul>
<p><img src="img/boundary-testing/examples/on_off_points2.svg" alt="On-, off-, in- and out-points 2"></p>
<p>Note that, depending on the condition, an on-point can be either an in- or an out-point.</p>
<p>As a tester, you devise test cases for these different points: a test case for the 
on-point, a test case for the off-point, a test case for a single in-point (as all in-points
belong to the same equivalence partition), and a test case for a single out-point (as all
out-points also belong to the same equivalence partition).</p>
<h2 id="deriving-tests-for-multiple-conditions">Deriving tests for multiple conditions</h2>
<p>In the previous example, we looked at one condition and its boundary.
However, in most programs you will find statements that consist of multiple conditions,
e.g., <code>a &gt; 10 &amp;&amp; b &lt; 20 &amp;&amp; c == 10 &amp;&amp; d &gt;= 50</code>. (Note that these conditions might be
expressed in a single <code>if</code> statement, but also spread all over a method or a class; it
is up to the tester to identify how these different conditions interact with each other).</p>
<p>In such cases, the number of boundary tests might explode. Imagine a program composed
of 5 different conditions. If we decide to write 4 test cases (on, off, in, out points) for 
each of the conditions, and make sure we test all the possible combinations among them,
we end up with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>4</mn><mn>5</mn></msup><mo>=</mo><mn>1</mn><mn>0</mn><mn>2</mn><mn>4</mn></mrow><annotation encoding="application/x-tex">4^5=1024</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8141079999999999em;"></span><span class="strut bottom" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">4</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord mathrm mtight">5</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">&#x200B;</span></span>&#x200B;</span></span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">2</span><span class="mord mathrm">4</span></span></span></span> tests. This is simply too much.</p>
<p>To effectively test the boundaries in these more complicated decisions, while
minimising the number of required tests,
we can use the <strong>simplified domain testing strategy</strong>, proposed by Jeng and Weyuker.
The idea of this strategy is to test each boundary separately, i.e. independent of the other conditions.</p>
<p>To do so, <strong>for each boundary</strong>:</p>
<ul>
<li>We pick the on- and off-point and we create one test case for each of these two points.</li>
<li>As we want to test each boundary independently, we choose in-points for the other variables/conditions. Note that we always choose in-points, regardless of the Boolean expression being connected by means of ANDs or ORs. In practice, we want all the other conditions to return true, so that we can evaluate the outcome of the condition under test independently.</li>
<li>It is important to vary the chosen in-points in the different tests, and to not choose the on- or off-point. This gives us the ability to partially check that the program gives the correct results for some in-points. If we would set the in-point to the on- or off-point, we would be testing two boundaries at once.</li>
</ul>
<p>To find these values and display the test cases in a structured manner, we use a <strong>domain matrix</strong>.
In general, the table looks like the following:</p>
<p><img src="img/boundary-testing/boundary_template.png" alt="Template for domain matrix"></p>
<p>In this template, we have two conditions with two parameters (see the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mi>a</mi><mo>&#x2227;</mo><mi>y</mi><mo>&gt;</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">x &gt; a \land y &gt; b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">&gt;</span><span class="mord mathit">a</span><span class="mbin">&#x2227;</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">&gt;</span><span class="mord mathit">b</span></span></span></span> condition).
We list the variables, with all their conditions.
Each condition has two rows: one for the on-point and one for the off-point.
Each variable has an additional row for the typical (in-) values.
These are used when testing the other boundary.</p>
<p>Each column that corresponds to a test case has two coloured cells.
In the coloured cells you have to fill in the correct values.
Each of these pairs of values will then give a test case.
If we implement all the test cases that the domain matrix gives us, 
we exercise each boundary both for the on- and off-point independent of the other parameters.</p>
<p>Let us walk through another example:</p>
<blockquote>
<p><strong>Requirement: Pizza or pasta</strong></p>
<p>The program decides whether a person should eat pizza or pasta.
Given two random numbers, x and y, if x is in between <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>5</mn><mo separator="true">,</mo><mn>2</mn><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[5,20]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">[</span><span class="mord mathrm">5</span><span class="mpunct">,</span><span class="mord mathrm">2</span><span class="mord mathrm">0</span><span class="mclose">]</span></span></span></span>
and y is smaller than or equal to 89, the program returns &quot;pizza&quot;.
Otherwise it returns &quot;pasta&quot;. </p>
</blockquote>
<p>A simple implementation of this program would be:</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">pizzaOrPasta</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{
  <span class="hljs-keyword">return</span> (x &gt;= <span class="hljs-number">5</span> &amp;&amp; x &lt; <span class="hljs-number">20</span> &amp;&amp; y &lt;= <span class="hljs-number">89</span>) ?
    <span class="hljs-string">&quot;pizza&quot;</span> :
    <span class="hljs-string">&quot;pasta&quot;</span>;
}
</code></pre>
<p>If we derive test cases based on the specification, we end up with at least two partitions:</p>
<ul>
<li><strong>Pizza</strong>: the program returns pizza. T1={x=15, y=50}.</li>
<li><strong>Pasta</strong>: the program returns pasta. T2={x=15, y=100}.</li>
</ul>
<p>(Now that you are more experienced in testing, you can probably see that these
two partitions are not enough.)</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PizzaPastaTest</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PizzaPasta pp = <span class="hljs-keyword">new</span> PizzaPasta();

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pizza</span><span class="hljs-params">()</span> </span>{
    assertEquals(<span class="hljs-string">&quot;pizza&quot;</span>, pp.pizzaOrPasta(<span class="hljs-number">15</span>, <span class="hljs-number">50</span>));
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pasta</span><span class="hljs-params">()</span> </span>{
    assertEquals(<span class="hljs-string">&quot;pasta&quot;</span>, pp.pizzaOrPasta(<span class="hljs-number">15</span>, <span class="hljs-number">100</span>));
  }
}
</code></pre>
<p>Let us now apply boundary testing. Note how easy it is for a developer to
make a mistake, e.g., confusing <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">x &gt;= 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">&gt;</span><span class="mrel">=</span><span class="mord mathrm">5</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>&gt;</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">x &gt; 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">x</span><span class="mrel">&gt;</span><span class="mord mathrm">5</span></span></span></span>.</p>
<p>We start by making the domain matrix, having space for each of the conditions and both parameters.</p>
<p><img src="img/boundary-testing/examples/boundary_table_empty.png" alt="Empty boundary table example"></p>
<p>Given that the statement has three conditions, we therefore will devise
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>&#xD7;</mo><mn>3</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">2 \times 3 = 6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.64444em;"></span><span class="strut bottom" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">2</span><span class="mbin">&#xD7;</span><span class="mord mathrm">3</span><span class="mrel">=</span><span class="mord mathrm">6</span></span></span></span> tests.
If we fill the table with the on-, off-, and typical random in points, we end up
with the following tests:</p>
<p><img src="img/boundary-testing/examples/boundary_table.png" alt="Boundary tables example filled in"></p>
<p>Now we have derived the six test cases that we can use to test the boundaries:</p>
<ul>
<li>T1={x=5, y=24}, output=pizza</li>
<li>T2={x=4, y=13}, output=pasta</li>
<li>T3={x=20, y=-75}, output=pasta</li>
<li>T4={x=19, y=48}, output=pizza</li>
<li>T5={x=15, y=89}, output=pizza</li>
<li>T6={x=8, y=90}, output=pasta</li>
</ul>
<pre><code class="lang-java"><span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">boundary_x1</span><span class="hljs-params">()</span> </span>{
  assertEquals(<span class="hljs-string">&quot;pizza&quot;</span>, pp.pizzaOrPasta(<span class="hljs-number">5</span>, <span class="hljs-number">24</span>));
  assertEquals(<span class="hljs-string">&quot;pasta&quot;</span>, pp.pizzaOrPasta(<span class="hljs-number">4</span>, <span class="hljs-number">13</span>));
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">boundary_x2</span><span class="hljs-params">()</span> </span>{
  assertEquals(<span class="hljs-string">&quot;pasta&quot;</span>, pp.pizzaOrPasta(<span class="hljs-number">20</span>, -<span class="hljs-number">75</span>));
  assertEquals(<span class="hljs-string">&quot;pizza&quot;</span>, pp.pizzaOrPasta(<span class="hljs-number">19</span>, <span class="hljs-number">48</span>));
}

<span class="hljs-meta">@Test</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">boundary_y</span><span class="hljs-params">()</span> </span>{
  assertEquals(<span class="hljs-string">&quot;pizza&quot;</span>, pp.pizzaOrPasta(<span class="hljs-number">15</span>, <span class="hljs-number">89</span>));
  assertEquals(<span class="hljs-string">&quot;pasta&quot;</span>, pp.pizzaOrPasta(<span class="hljs-number">8</span>, <span class="hljs-number">90</span>));
}
</code></pre>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/rPcMJg62wM4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>



<h2 id="boundaries-that-are-not-so-explicit">Boundaries that are not so explicit</h2>
<p>Let&apos;s revisit the example from the a previous chapter. There, we had a program
where the goal was to return the number of bars needed in order to build some boxes of chocolates:</p>
<blockquote>
<p><strong>Chocolate bars</strong></p>
<p>A package should store a total number of kilos. 
There are small bars (1 kilo each) and big bars (5 kilos each). 
We should calculate the number of small bars to use, 
assuming we always use big bars before small bars. Return -1 if it can&apos;t be done.</p>
<p>The input of the program is thus the number of small bars, the number of big bars,
and the total number of kilos to store.</p>
</blockquote>
<p>And these were the classes we derived after applying the category/partition method:</p>
<ul>
<li><strong>Need only small bars</strong>. A solution that only uses the provided small bars.</li>
<li><strong>Need only big bars</strong>. A solution that only uses the provided big bars.</li>
<li><strong>Need small + big bars</strong>. A solution that has to use both small and big bars.</li>
<li><strong>Not enough bars</strong>. A case in which it&apos;s not possible, because there are not enough bars.</li>
<li><strong>Not from the specs</strong>: An exceptional case.</li>
</ul>
<p>As we saw in the previous chapter, the following code passed all the tests we derived:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChocolateBars</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANNOT_PACK_BAG = -<span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> small, <span class="hljs-keyword">int</span> big, <span class="hljs-keyword">int</span> total)</span> </span>{
        <span class="hljs-keyword">int</span> maxBigBoxes = total / <span class="hljs-number">5</span>;
        <span class="hljs-keyword">int</span> bigBoxesWeCanUse = Math.min(maxBigBoxes, big);
        total -= (bigBoxesWeCanUse * <span class="hljs-number">5</span>);

        <span class="hljs-keyword">if</span>(small &lt;= total)
            <span class="hljs-keyword">return</span> CANNOT_PACK_BAG;
        <span class="hljs-keyword">return</span> total;
    }
}
</code></pre>
<p>However, the following input makes the program to fail: <code>(2,3,17)</code>! </p>
<p>Note that the input <code>(2,3,17)</code> belongs to the <strong>need small + big bars</strong> partition. In this case,
the program should make use of all the big bars (there are 3 available) and then <em>all</em> the small bars available (there are 
2 available). Note that the buggy program would work if we had 3 available small bars (having <code>(3, 3, 17)</code> as input).</p>
<p>The bug lies on the <code>if</code> condition. It should be <code>if(small &lt; total)</code> instead of
<code>if(small &lt;= total)</code>:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChocolateBars</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANNOT_PACK_BAG = -<span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> small, <span class="hljs-keyword">int</span> big, <span class="hljs-keyword">int</span> total)</span> </span>{
        <span class="hljs-keyword">int</span> maxBigBoxes = total / <span class="hljs-number">5</span>;
        <span class="hljs-keyword">int</span> bigBoxesWeCanUse = Math.min(maxBigBoxes, big);
        total -= (bigBoxesWeCanUse * <span class="hljs-number">5</span>);

        <span class="hljs-comment">// we fixed the bug here!</span>
        <span class="hljs-keyword">if</span>(small &lt; total)
            <span class="hljs-keyword">return</span> CANNOT_PACK_BAG;
        <span class="hljs-keyword">return</span> total;
    }
}
</code></pre>
<p>This bug is clearly an instance of a bug that should have been detected by boundary testing.
The problem is that this boundary is just less explicit from the requirements.</p>
<p>As we defined at the beginning of this chapter,
boundaries also happen when we are going from &quot;one partition&quot; to 
another. There is a &quot;single condition&quot; that we can use as clear source.
In these cases, what we should do is to devise test cases for a sequence of inputs that move
from one partition to another.</p>
<p><img src="img/boundary-testing/partition-boundary.png" alt="Partitions and boundaries"></p>
<p>Let us focus on the bug caused by the <code>(2,3,17)</code> input:</p>
<ul>
<li><code>(1,3,17)</code> should return <em>not possible</em> (1 small bar is not enough). This test case belongs to the <strong>not enough bars</strong> partition.</li>
<li><code>(2,3,17)</code> should return 2. This test case belongs to <strong>need for small + big bars</strong> partition.</li>
</ul>
<p>There is a boundary between <code>(1,3,17)</code> and <code>(2,3,17)</code>. We should make sure the software still behaves correctly in these cases.</p>
<p>Looking at the <strong>only big bars</strong> partition, we should find inputs that transition from this
partition to another one:</p>
<ul>
<li><code>(10, 1, 10)</code> returns 5. This input belongs to the <strong>need small + big bars</strong> partition.</li>
<li><code>(10, 2, 10)</code> returns 0. This input belongs to the <strong>need only big bars</strong> partition.</li>
</ul>
<p>Finally, with the <strong>only small bars</strong> partition:</p>
<ul>
<li><code>(3, 2, 3)</code> returns 3. We need only small bars here, and therefore, this input belongs to the <strong>only small bars</strong> partition.</li>
<li><code>(2, 2, 3)</code> returns -1. We can&apos;t make the boxes. This input belongs to the <strong>Not enough bars</strong> partition.</li>
</ul>
<p>A partition might make boundaries with more than just one single another partitions. 
The <strong>only small bars</strong> partition has boundaries not only with the <strong>not enough bars</strong> partition (as we saw above), but also with the <strong>only big bars</strong> partition:</p>
<ul>
<li><code>(4, 2, 4)</code> returns 4. We need only small bars here, and therefore, this input belongs to the <strong>only small bars</strong> partition.</li>
<li><code>(4, 2, 5)</code> returns 0. We need only big bars here, and therefore, this input belongs to the <strong>only big bars</strong> partition.</li>
</ul>
<p>A lesson we learn from this example is that boundary bugs may not 
only emerge out of &quot;clear <code>if</code> conditions&quot; we
see in the implementation. Boundary bugs also happen in more subtle
interactions among partitions.</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/uP_SpXtHxoQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>




<h2 id="automating-boundary-testing-with-junit-via-parameterised-tests">Automating boundary testing with JUnit (via Parameterised Tests)</h2>
<p>You might have noticed that in the domain matrix we always have a certain number of input values and, implicitly, an expected output value.
We could just implement the boundary tests by making a separate method for each test, or by
grouping them per boundary, as we have been doing so far.</p>
<p>However, the number of test methods can quickly become large and unmanageable.
Moreover, the code in these test methods will be largely the same,
as they all have the same structure, only with different input and output values.</p>
<p>Luckily, JUnit offers a solution where we can generalise the implementation of a test
method, and run it with different inputs and expected outputs: <strong>Parameterised Tests</strong>.
As the name suggests, with a parameterised test, developers 
can define a test method with parameters.
To define a parameterised test, you make use of the <code>@ParameterizedTest</code> annotation, 
instead of the usual <code>@Test</code> annotation.</p>
<p>For each parameter you want to pass to the &quot;template test method&quot;, you define a 
parameter in the method&apos;s parameter list (note that so far, all our JUnit methods had
no parameters). For example, a test method <code>t1(int a, int b)</code> receives two parameters,
<code>int a</code> and <code>int b</code>. The developer uses these two variables in the body of the test
method, often in places where the developer would have a hard-coded value.</p>
<p>The next step is to feed JUnit with a list of inputs which it will pass
to the test method.
In general, these values are provided by a <code>Source</code>.
Here, we will make use of a <code>CsvSource</code>.
With it, each test case is given as a comma-separated list of input values.
To execute multiple tests with the same test method, 
the <code>CsvSource</code> expects list of strings, where each string represents 
the input and output values for one test case.
The <code>CsvSource</code> is an annotation itself, so in an implementation 
it would like like the following: <code>@CsvSource({&quot;value11, value12&quot;, &quot;value21, value22&quot;, &quot;value31, value32&quot;, ...})</code></p>
<p>Let us implement the boundary test cases that we derived in the <em>Pizza or Pasta</em> example, using a parameterised test.</p>
<p>To automate the tests we create a test method with three parameters: <code>x</code>, <code>y</code>, <code>expectedResult</code>.
<code>x</code> and <code>y</code> are integers.
The <code>expectedResult</code> is a String, containing the expected output, <em>pasta</em> or <em>pizza</em>.</p>
<pre><code class="lang-java"><span class="hljs-meta">@ParameterizedTest</span>
<span class="hljs-meta">@CsvSource</span>({
    <span class="hljs-string">&quot;5, 24, pizza&quot;</span>,
    <span class="hljs-string">&quot;4, 13, pasta&quot;</span>,
    <span class="hljs-string">&quot;20, -75, pasta&quot;</span>,
    <span class="hljs-string">&quot;19, 48, pizza&quot;</span>,
    <span class="hljs-string">&quot;15, 89, pizza&quot;</span>,
    <span class="hljs-string">&quot;8, 90, pasta&quot;</span>
})
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">boundary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, String expectedResult)</span> </span>{
  assertEquals(expectedResult, pp.pizzaOrPasta(x, y));
}
</code></pre>
<p>The behaviour
of this single test method is the same as the six test methods we declared before. However, this time we achieve the same result with a much smaller amount of code.</p>
<p>JUnit will run the <code>boundary</code> test six times: one for each line in the <code>@CsvSource</code>. 
In your IDE, you might even see JUnit showing each of the test cases being executed:</p>
<p><img src="img/boundary-testing/junit.png" alt="Parameterised tests in JUnit"></p>
<p>JUnit&apos;s Parameterised tests have more functionalities and ways of providing input data.
We point the reader to JUnit&apos;s manual.</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fFksNXJJfiE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>




<h2 id="the-correct-way">The CORRECT way</h2>
<p>The book <em>Pragmatic Unit Testing in Java 8 with JUnit</em>, by Langr, Hunt, and Thomas, has an interesting discussion about boundary conditions.
Authors call it the <strong>CORRECT</strong> way, as each letter represents one boundary condition to consider:</p>
<ul>
<li><p><strong>Conformance:</strong></p>
<ul>
<li>Many data elements must conform to a specific format. Example: e-mail addresses (always name@domain). If you expect an e-mail address, and you do not receive one, your software might crash.</li>
<li>Required action: Test what happens when your input is not in conformance with what is expected.</li>
</ul>
</li>
<li><p><strong>Ordering:</strong></p>
<ul>
<li>Some inputs might come in a specific order. Imagine a system that receives different products to be inserted in a basket. The order of the data might influence the output. What happens if the list is ordered? Unordered?</li>
<li>Required action: Make sure our program works even if the data comes in an unordered manner (or return an elegant failure to user, avoiding the crash).</li>
</ul>
</li>
<li><p><strong>Range:</strong></p>
<ul>
<li>Inputs should usually be within a certain range. Example: Age should always be greater than 0 and smaller than 125.</li>
<li>Required action: Test what happens when we provide inputs that are outside of the expected range.</li>
</ul>
</li>
<li><p><strong>Reference:</strong></p>
<ul>
<li>In OOP systems, objects refer to other objects. Sometimes the relationships between the objects are extensive and there may be external dependencies. What happens if these dependencies do not behave as expected?</li>
<li>Required action: When testing a method, consider:<ul>
<li>What it references outside its scope</li>
<li>What external dependencies it has</li>
<li>Whether it depends on the object being in a certain state</li>
<li>Any other conditions that must exist</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Existence:</strong></p>
<ul>
<li>Does &quot;something&quot; really exist? What if it does not? Imagine you query a database, and your database returns an empty result. Will our software behave correctly?</li>
<li>Required action: Does the system behave correctly when something that is expected to exist, does not?</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Cardinality:</strong></p>
<ul>
<li>In simple words, our loop performed one step less (or more) than it should.</li>
<li>Required action: Test loops in different situations, such as when it actually performs zero iterations,
one iterations, or many. (Loops are further discussed in the structural-based testing chapter).</li>
</ul>
</li>
<li><p><strong>Time</strong></p>
<ul>
<li>Systems rely on dates and times. What happens if the system receives inputs that are not
ordered in regards to date and time?</li>
<li>Timeouts: Does the system handle timeouts well?</li>
<li>Concurrency: Does the system handle concurrency well?</li>
</ul>
</li>
</ul>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/oxNEUYqEvzM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>





<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/PRVqsJ5fT2I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>




<h2 id="exercises">Exercises</h2>
<p><strong>Exercise 1.</strong>
We have the following method.</p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sameEnds</span><span class="hljs-params">(String string)</span> </span>{
  <span class="hljs-keyword">int</span> length = string.length();
  <span class="hljs-keyword">int</span> half = length / <span class="hljs-number">2</span>;

  String left = <span class="hljs-string">&quot;&quot;</span>;
  String right = <span class="hljs-string">&quot;&quot;</span>;

  <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; half; i++) {
    left += string.charAt(i);
    right = string.charAt(length - <span class="hljs-number">1</span> - i) + right;

    <span class="hljs-keyword">if</span> (left.equals(right))
      size = left.length();
  }

  <span class="hljs-keyword">return</span> string.substring(<span class="hljs-number">0</span>, size);
}
</code></pre>
<p>Perform boundary analysis on the condition in the for-loop: <code>i &lt; half</code>, i.e. what are the on- and off-point and the in- and out-points?
You can give the points in terms of the variables used in the method.</p>
<p><strong>Exercise 2.</strong>
Perform boundary analysis on the following decision: <code>n % 3 == 0 &amp;&amp; n % 5 == 0</code>.
What are the on- and off-points?</p>
<p><strong>Exercise 3.</strong>
A game has the following condition: <code>numberOfPoints &lt;= 570</code>.
Perform boundary analysis on the condition.
What are the on- and off-point of the condition?
Also give an example for both an in-point and an out-point.</p>
<p><strong>Exercise 4.</strong>
We extend the game with a more complicated condition: <code>(numberOfPoints &lt;= 570 &amp;&amp; numberOfLives &gt; 10) || energyLevel == 5</code>.</p>
<p>Perform boundary analysis on this condition.
What is the resulting domain matrix?</p>
<p><strong>Exercise 5.</strong>
Regarding <strong>boundary analysis of inequalities</strong> (e.g., <code>a &lt; 10</code>), which of the following statements <strong>is true</strong>?</p>
<ol>
<li>There can only be a single on-point which always makes the condition true.</li>
<li>There can be multiple on-points for a given condition which may or may not make the condition true.</li>
<li>There can only be a single off-point which may or may not make the condition false.</li>
<li>There can be multiple off-points for a given condition which always make the condition false.</li>
</ol>
<p><strong>Exercise 6.</strong>
A game has the following condition: <code>numberOfPoints &gt; 1024</code>. Perform a boundary analysis.</p>
<p><strong>Exercise 7.</strong>
Which one of the following statements about the <strong>CORRECT</strong> principles is <strong>true</strong>?</p>
<ol>
<li>We assume that external dependencies are already on the right state for the test (REFERENCE).</li>
<li>We test different methods from the same class in an isolated way in order to avoid order issues (TIME).</li>
<li>Whenever we encounter a loop, we always test whether the program works for 0, 1, and 10 iterations (CARDINALITY).</li>
<li>We always test the behaviour of our program when any expected data does not exist (EXISTENCE).</li>
</ol>
<h2 id="references">References</h2>
<ul>
<li><p>Jeng, B., &amp; Weyuker, E. J. (1994). A simplified domain-testing strategy. ACM Transactions on Software Engineering and Methodology (TOSEM), 3(3), 254-270.</p>
</li>
<li><p>Chapter 7 of Pragmatic Unit Testing in Java 8 with Junit. Langr, Hunt, and Thomas. Pragmatic Programmers, 2015.</p>
</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="specification-based-testing.html" class="navigation navigation-prev " aria-label="Previous page: Specification-based testing">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="structural-testing.html" class="navigation navigation-next " aria-label="Next page: Structural-based testing">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Boundary testing","level":"3.1.2","depth":2,"next":{"title":"Structural-based testing","level":"3.1.3","depth":2,"path":"chapters/testing-techniques/structural-testing.md","ref":"chapters/testing-techniques/structural-testing.md","articles":[]},"previous":{"title":"Specification-based testing","level":"3.1.1","depth":2,"path":"chapters/testing-techniques/specification-based-testing.md","ref":"chapters/testing-techniques/specification-based-testing.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["hints","katex","ga","page-toc-button","splitter","back-to-top-button","chapter-fold"],"pluginsConfig":{"chapter-fold":{},"splitter":{},"search":{},"hints":{"danger":"fa fa-exclamation-circle","info":"fa fa-info-circle","tip":"fa fa-mortar-board","working":"fa fa-wrench"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"page-toc-button":{"maxTocDepth":2,"minTocSize":2},"back-to-top-button":{},"ga":{"configuration":"auto","token":"UA-154019382-1"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"chapters/testing-techniques/boundary-testing.md","mtime":"2020-04-06T03:15:15.281Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-04-09T18:42:34.468Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

