
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>Specification-based testing Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-hints/plugin-hints.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-page-toc-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-splitter/splitter.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-back-to-top-button/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="boundary-testing.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../preface/structure.html">
            
                <a href="../preface/structure.html">
            
                    
                    Structure of the book
            
                </a>
            

            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../getting-started/">
            
                <a href="../getting-started/">
            
                    
                    Getting started with software testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="2.1.1" data-path="../getting-started/why-software-testing.html">
            
                <a href="../getting-started/why-software-testing.html">
            
                    
                    Why software testing?
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.2" data-path="../getting-started/testing-principles.html">
            
                <a href="../getting-started/testing-principles.html">
            
                    
                    Principles of software testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.1.3" data-path="../getting-started/test-automation.html">
            
                <a href="../getting-started/test-automation.html">
            
                    
                    Software testing automation
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="./">
            
                <a href="./">
            
                    
                    Testing techniques
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter active" data-level="3.1.1" data-path="specification-based-testing.html">
            
                <a href="specification-based-testing.html">
            
                    
                    Specification-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.2" data-path="boundary-testing.html">
            
                <a href="boundary-testing.html">
            
                    
                    Boundary testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.3" data-path="structural-testing.html">
            
                <a href="structural-testing.html">
            
                    
                    Structural-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.4" data-path="model-based-testing.html">
            
                <a href="model-based-testing.html">
            
                    
                    Model-based testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.5" data-path="design-by-contracts.html">
            
                <a href="design-by-contracts.html">
            
                    
                    Design-by-contracts
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.1.6" data-path="property-based-testing.html">
            
                <a href="property-based-testing.html">
            
                    
                    Property-based testing
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../pragmatic-testing/">
            
                <a href="../pragmatic-testing/">
            
                    
                    Pragmatic software testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="4.1.1" data-path="../pragmatic-testing/testing-pyramid.html">
            
                <a href="../pragmatic-testing/testing-pyramid.html">
            
                    
                    The testing pyramid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.2" data-path="../pragmatic-testing/mock-objects.html">
            
                <a href="../pragmatic-testing/mock-objects.html">
            
                    
                    Mock objects
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.3" data-path="../pragmatic-testing/design-for-testability.html">
            
                <a href="../pragmatic-testing/design-for-testability.html">
            
                    
                    Design for testability
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.4" data-path="../pragmatic-testing/tdd.html">
            
                <a href="../pragmatic-testing/tdd.html">
            
                    
                    Test-driven development
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.1.5" data-path="../pragmatic-testing/test-code-quality.html">
            
                <a href="../pragmatic-testing/test-code-quality.html">
            
                    
                    Test code quality and engineering
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../intelligent-testing/">
            
                <a href="../intelligent-testing/">
            
                    
                    Intelligent testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="5.1.1" >
            
                <span>
            
                    
                    Random testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.2" data-path="../intelligent-testing/mutation-testing.html">
            
                <a href="../intelligent-testing/mutation-testing.html">
            
                    
                    Mutation testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.3" data-path="../intelligent-testing/fuzzing.html">
            
                <a href="../intelligent-testing/fuzzing.html">
            
                    
                    Fuzzing testing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.1.4" >
            
                <span>
            
                    
                    Search-based software testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../testing-into-context/">
            
                <a href="../testing-into-context/">
            
                    
                    Testing in the context
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="6.1.1" data-path="../testing-into-context/web-testing.html">
            
                <a href="../testing-into-context/web-testing.html">
            
                    
                    Web testing (soon)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.2" >
            
                <span>
            
                    
                    Database testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.3" >
            
                <span>
            
                    
                    Mobile testing (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.4" >
            
                <span>
            
                    
                    Continuous experimentation (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="6.1.5" >
            
                <span>
            
                    
                    Embedded software testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="7.1" data-path="../non-functional-testing/">
            
                <a href="../non-functional-testing/">
            
                    
                    Non-functional testing
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="7.1.1" data-path="../non-functional-testing/security-testing.html">
            
                <a href="../non-functional-testing/security-testing.html">
            
                    
                    Security testing (soon)
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="7.1.2" >
            
                <span>
            
                    
                    Performance testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    
        
        <li class="divider"></li>
        
        
    
        <li class="chapter " data-level="8.1" >
            
                <span>
            
                    
                    Software Quality
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="8.1.1" >
            
                <span>
            
                    
                    Code reviews (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="8.1.2" >
            
                <span>
            
                    
                    Code metrics (soon)
            
                </span>
            

            
        </li>
    
        <li class="chapter " data-level="8.1.3" >
            
                <span>
            
                    
                    Ethics and testing (soon)
            
                </span>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >Specification-based testing</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="specification-based-testing">Specification-Based Testing</h1>
<p>In this chapter, we explore <strong>specification-based testing</strong> techniques. These use the <em>requirements</em> of the program (often written as text; think of user stories and/or UML use cases) as input for testing.</p>
<p>In simple terms, we devise a set
of inputs, where each input tackles one part (or <em>partition</em>)
of the program.</p>
<p>Given that specification-based techniques require no knowledge
of how the software inside the &#x201C;box&#x201D; is structured
(i.e., it does not matter if it is developed in Java or Python), they are also known
as <strong>black box testing</strong>.</p>
<h2 id="partitioning-the-input-space">Partitioning the input space</h2>
<p>Programs are usually too complex to be tested with just a single test case.
There are different cases in which the program is executed 
and its execution often depends on various factors, such as the input
to the program.</p>
<p>Let&apos;s use a small program as an example. The specification below talks about a program that decides whether a given year is a leap year or not. </p>
<blockquote>
<p><strong>Requirement: Leap year</strong></p>
<p>Given a specific year as an input, the program should return <em>true</em> if 
the provided year is a leap year and <em>false</em> if it is not.</p>
<p>A year is a leap year if:</p>
<ul>
<li>the year is divisible by 4;</li>
<li>and the year is not divisible by 100;</li>
<li>except when the year is divisible by 400 (because then it is still a leap year)</li>
</ul>
</blockquote>
<p>To find a good set of test cases, often referred to as a <em>test suite</em>,
we split the program into <em>classes</em>.
In other words, we divide the input space of
the program in such a way that each class is 1)
different, i.e. it is unique, where
no two partitions represent/exercise the same behaviour,
2) can easily verify whether that behaviour is correct or not.</p>
<p>By looking at the requirements above, we can derive the
following classes/partitions:</p>
<ul>
<li>Year is divisible by 4, but not divisible by 100 = leap year, TRUE</li>
<li>Year is divisible by 4, divisible by 100, divisible by 400 = leap year, TRUE</li>
<li>Not divisible by 4 = not a leap year, FALSE</li>
<li>Divisible by 4, divisible by 100, but not divisible by 400 = not leap year, FALSE</li>
</ul>
<p>Note how each class above exercises the program in different ways.</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kSLbxmXcPPI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>




<h2 id="equivalence-partitioning">Equivalence partitioning</h2>
<p>The partitions above are not test cases that we can implement directly because
each partition might be instantiated by an infinite number of inputs. For example,
for the partition &quot;year not divisible by 4&quot;, there are infinitely many numbers
that are not divisible by 4 which we could use as concrete inputs to the program.
So how do we know which concrete input to instantiate for each of the partitions?</p>
<p>As we discussed earlier, each partition exercises the program in a certain way.
In other words, all input values from one specific partition will make the program
behave in the same way.
Therefore, any input we select should give us the same result.
We assume that, if the program behaves correctly for one given input,
it will work correctly for all other inputs from that class.
This idea of inputs being equivalent to each other
is called <strong>equivalence partitioning</strong>.
Thus, it does not matter which precise input we select and one test case per
partition will be enough.</p>
<p>Let&#x2019;s now write some JUnit tests for the leap year problem. Remember that the name of a test method
in JUnit can be anything. It is good to name your test method after the 
partition that the method tests.</p>
<p><div class="alert alert-success hints-alert"><div class="hints-icon"><i class="fa fa-mortar-board"></i></div><div class="hints-container"><p>We discuss more about test code quality and best practices in writing test code in
a future chapter.</p>
</div></div></p>
<p>The <em>Leap Year</em> specification has been implemented by a developer in the following way:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeapYear</span> </span>{

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLeapYear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year)</span> </span>{
    <span class="hljs-keyword">if</span> (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    <span class="hljs-keyword">if</span> (year % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>)
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">return</span> year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>;
  }
}
</code></pre>
<p>With the classes we devised above, we have 4 test cases in total (i.e., one test case
for each class/partition).
As any input can be used for a given partition,
the following inputs will be used for the partitions:</p>
<ul>
<li>2016, divisible by 4, not divisible by 100.</li>
<li>2000, divisible by 4, also divisible by 100 and by 400.</li>
<li>39, not divisible by 4.</li>
<li>1900, divisible by 4 and 100, not by 400.</li>
</ul>
<p>Implementing this using JUnit gives the following code for the tests:</p>
<pre><code class="lang-java"><span class="hljs-keyword">package</span> tudelft.leapyear;

<span class="hljs-keyword">import</span> org.junit.jupiter.api.Assertions;
<span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeapYearTests</span> </span>{

  <span class="hljs-keyword">private</span> LeapYear leapYear;

  <span class="hljs-meta">@BeforeEach</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
    leapYear = <span class="hljs-keyword">new</span> LeapYear();
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leapYearsNotCenturialTest</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">boolean</span> leap = leapYear.isLeapYear(<span class="hljs-number">2016</span>);
    assertTrue(leap);
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leapYearsCenturialTest</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">boolean</span> leap = leapYear.isLeapYear(<span class="hljs-number">2000</span>);
    assertTrue(leap);
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nonLeapYearsTest</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">boolean</span> leap = leapYear.isLeapYear(<span class="hljs-number">39</span>);
    assertFalse(leap);
  }

  <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nonLeapYearsCenturialTest</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">boolean</span> leap = leapYear.isLeapYear(<span class="hljs-number">1900</span>);
    assertFalse(leap);
  }
}
</code></pre>
<p>Note that each test method covers one of the partitions and the naming of the method refers to the partition it covers.</p>
<p>For those who are learning JUnit: Note that the <code>setup</code> method is executed 
before each test, thanks to the <code>BeforeEach</code> annotation.
For each test, it creates a <code>LeapYear</code> object.
This is then used by the tests to execute the method under test.
In each test we first determine the result of the method.
After the method returns a value, we assert that this is the expected value.</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/mXmFiiifwaE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>



<h2 id="category-partition-method">Category-Partition Method</h2>
<p>So far we have derived partitions by just looking at the specification of the program.
We basically used our experience and knowledge to derive the test cases.
We now go over a more systematic way of deriving these partitions: the <strong>Category-Partition</strong> method.</p>
<p>The method gives us a systematic way of deriving test cases, based on the characteristics of the input parameters. It also brings down the number of tests to a feasible number.</p>
<p>We now set out the steps of this method and then we illustrate the process with an example.</p>
<ol>
<li>Identify the parameters, or the input of the program. For example, the parameters your classes and methods receive.</li>
<li><p>Derive characteristics of each parameter. For example, an <code>int year</code> should be a positive integer number between 0 and infinite. </p>
<ul>
<li>Some of these characteristics can be found directly in the specification of the program.</li>
<li>Others might not be found from specifications. For example, an input cannot be <code>null</code> if the method does not handle that well.</li>
</ul>
</li>
<li><p>Add constraints in order to minimise the test suite.</p>
<ul>
<li>Identify invalid combinations. For some characteristics it might not be possible to combine them with other characteristics.</li>
<li>Exceptional behaviour does not always have to be combined with all the different values of the other inputs. For example, trying a single <code>null</code> input might be enough to test that corner case.</li>
</ul>
</li>
<li><p>Generate combinations of the input values. These are the test cases.</p>
</li>
</ol>
<p>Let&apos;s apply the technique in the following program:</p>
<blockquote>
<p><strong>Requirement: Christmas discount</strong></p>
<p>The system should give a 25% discount on the cart when it is Christmas.
The method has two input parameters: the total price of the products in the cart, and the date.
When it is not Christmas it just returns the original price; otherwise it applies the discount.</p>
</blockquote>
<p>Following the category-partition method:</p>
<ol>
<li><p>We have two parameters:</p>
<ul>
<li>The current date</li>
<li>The total price</li>
</ul>
</li>
<li><p>Now for each parameter we define the characteristics as:</p>
<ul>
<li>Based on the requirements, the only important characteristic is that the date can be either Christmas or not.</li>
<li>The price can be a positive number, or in certain circumstances it may be 0. Technically the price can also be a negative number. This is an exceptional case, as you cannot pay a negative amount.</li>
</ul>
</li>
<li><p>The number of characteristics and parameters is not too large in this case. As the negative price is an exceptional case, we can test this with just one combination, instead of with a date that is Christmas and a date that is not Christmas.</p>
</li>
<li><p>We combine the other characteristics to get the following test cases:</p>
<ul>
<li>Positive price on Christmas</li>
<li>Positive price not on Christmas</li>
<li>Price of 0 on Christmas</li>
<li>Price of 0 not on Christmas</li>
<li>Negative price on Christmas</li>
</ul>
</li>
</ol>
<p>Now we can implement these test cases.
Each of the test cases corresponds to one of the partitions that we want to test.</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/frzRmafsPBk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>


<p>Let&apos;s explore another example:</p>
<blockquote>
<p><strong>Requirement: Chocolate bars</strong></p>
<p>A package should store a total number of kilos. 
There are small bars (1 kilo each) and big bars (5 kilos each). 
We should calculate the number of small bars to use, 
assuming we always use big bars before small bars. Return -1 if it is impossible.</p>
<p>The input of the program is thus the number of small bars, the number of big bars,
and the total number of kilos to store.</p>
</blockquote>
<p>A possible implementation for this program is:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChocolateBars</span> </span>{

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANNOT_PACK_BAG = -<span class="hljs-number">1</span>;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> small, <span class="hljs-keyword">int</span> big, <span class="hljs-keyword">int</span> total)</span> </span>{
        <span class="hljs-keyword">int</span> maxBigBoxes = total / <span class="hljs-number">5</span>;
        <span class="hljs-keyword">int</span> bigBoxesWeCanUse = Math.min(maxBigBoxes, big);
        total -= (bigBoxesWeCanUse * <span class="hljs-number">5</span>);

        <span class="hljs-keyword">if</span>(small &lt;= total)
            <span class="hljs-keyword">return</span> CANNOT_PACK_BAG;
        <span class="hljs-keyword">return</span> total;

    }
}
</code></pre>
<p>In this requirement, the partitions are less clear and it is essential to understand the problem fully
in order to derive the partitions.</p>
<p>The classes/partitions are:</p>
<ul>
<li><strong>Need only small bars</strong>. A solution that only uses the provided small bars.</li>
<li><strong>Need only big bars</strong>. A solution that only uses the provided big bars.</li>
<li><strong>Need small + big bars</strong>. A solution that has to use both small and big bars.</li>
<li><strong>Not enough bars</strong>. A case in which it is impossible, because there are not enough bars.</li>
<li><strong>Not from the specs</strong>: An exceptional case.</li>
</ul>
<p>For each of these classes, we can devise concrete test cases:</p>
<ul>
<li><strong>Need only small bars</strong>. small = 4, big = 2, total = 3</li>
<li><strong>Need only big bars</strong>. small = 5, big = 3, total = 10</li>
<li><strong>Need small + big bars</strong>. small = 5, big = 3, total = 17</li>
<li><strong>Not enough bars</strong>. small = 1, big = 1, total = 10</li>
<li><strong>Not from the specs</strong>: small = -1, big = -1, total = -1</li>
</ul>
<p>In JUnit code:</p>
<pre><code class="lang-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChocolateBarsTest</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChocolateBars bars = <span class="hljs-keyword">new</span> ChocolateBars();
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notEnoughBars</span><span class="hljs-params">()</span> </span>{
        assertEquals(-<span class="hljs-number">1</span>, bars.calculate(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>));
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onlyBigBars</span><span class="hljs-params">()</span> </span>{
        assertEquals(<span class="hljs-number">0</span>, bars.calculate(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>));
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bigAndSmallBars</span><span class="hljs-params">()</span> </span>{
        assertEquals(<span class="hljs-number">2</span>, bars.calculate(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>));
    }

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onlySmallBars</span><span class="hljs-params">()</span> </span>{
        assertEquals(<span class="hljs-number">3</span>, bars.calculate(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>));
    }

    <span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">invalidValues</span><span class="hljs-params">()</span> </span>{
      assertEquals(-<span class="hljs-number">1</span>, bars.calculate(-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>));
    }
}
</code></pre>
<p>This example shows why deriving good test cases becomes more challenging, 
when the specifications are complex.</p>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/T8caAUwgquQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center>




<h2 id="random-testing-vs-specification-based-testing">Random testing vs specification-based testing</h2>
<p>One might think: but what if, instead of looking at the requirements,
a tester just keeps giving random inputs to the program?
<strong>Random testing</strong> is indeed a popular black-box technique where programs are tested by generating random inputs. </p>
<p>Although random testing can definitely help us in finding bugs, it is not an effective way to find bugs in a large input space. 
Developers/testers use their experience and knowledge of the program to test trouble-prone areas more effectively.
However, they generate a limited number of tests in a specific time period such as a day,
while computers can generate millions.
A combination of random testing and partition testing is therefore the most beneficial.</p>
<p><div class="alert alert-success hints-alert"><div class="hints-icon"><i class="fa fa-mortar-board"></i></div><div class="hints-container"><p>In future chapters, fuzzing testing and AI-based testing will be discussed, with information
about automated random testing.</p>
</div></div></p>
<h2 id="exercises">Exercises</h2>
<p><strong>Exercise 1.</strong>
What is an Equivalence Partition?</p>
<ol>
<li>A group of results that is produced by one method</li>
<li>A group of results that is produced by one input into different methods</li>
<li>A group of inputs that all make a method behave the same way</li>
<li>A group of inputs that exactly gives the same output in every method</li>
</ol>
<p><strong>Exercise 2.</strong>
We have a program called FizzBuzz.
It does the following:
Given an integer <code>n</code>, return the string form of the number followed by <code>&quot;!&quot;</code>.
So the integer 6 yields <code>&quot;6!&quot;</code>.
Except if the number is divisible by 3 use <code>&quot;Fizz&quot;</code> instead of the number, and if the number is divisible by 5 use <code>&quot;Buzz&quot;</code>, and if divisible by both 3 and 5, use <code>&quot;FizzBuzz&quot;</code>.</p>
<p>A novice tester is trying hard to devise as many tests as she can for
the FizzBuzz method.
She came up with the following tests:</p>
<ul>
<li>T1 = 15</li>
<li>T2 = 30</li>
<li>T3 = 8</li>
<li>T4 = 6</li>
<li>T5 = 25</li>
</ul>
<p>Which of these tests can be removed while keeping a good test suite?</p>
<p>Which concept can we use to determine the tests that can be removed?</p>
<p><strong>Exercise 3.</strong>
See a slightly modified version of HashMap&apos;s <code>put</code> method Javadoc. (Source code <a href="http://developer.classpath.org/doc/java/util/HashMap-source.html" target="_blank">here</a>).</p>
<pre><code class="lang-java"><span class="hljs-comment">/**
 * Puts the supplied value into the Map,
 * mapped by the supplied key.
 * If the key is already on the map, its
 * value will be replaced by the new value.
 *
 * <span class="hljs-doctag">NOTE:</span> Nulls are not accepted as keys;
 *  a RuntimeException is thrown when key is null.
 *
 * <span class="hljs-doctag">@param</span> key the key used to locate the value
 * <span class="hljs-doctag">@param</span> value the value to be stored in the HashMap
 * <span class="hljs-doctag">@return</span> the prior mapping of the key, or null if there was none.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>{
  <span class="hljs-comment">// implementation here</span>
}
</code></pre>
<p>Apply the category/partition method.
What are the minimal and most suitable partitions?</p>
<p><strong>Exercise 4.</strong>
Zip codes in country X are always composed of 4 numbers + 2 letters, e.g., 2628CD.
Numbers are in the range [1000, 4000].
Letters are in the range [C, M].</p>
<p>Consider a program that receives two inputs: an integer (for the 4 numbers) and a string (for the 2 letters), and returns true (valid zip code) or false (invalid zip code).</p>
<p>A tester comes up with the following partitions:</p>
<ol>
<li>[0,999]</li>
<li>[1000, 4000]</li>
<li>[2001, 3500]</li>
<li>[3500, 3999]</li>
<li>[4001, 9999]</li>
<li>[A-C]</li>
<li>[C-M]</li>
<li>[N-Z]</li>
</ol>
<p>Note that with [a, b] all numbers between and including a and b are in the domain.
The same goes with letters like [A-Z].</p>
<p>Which of these partitions are valid (and good) partitions, i.e. which can actually be used as partitions?
Name each of the valid partitions, corresponding to how they exercise the program.</p>
<p><strong>Exercise 5.</strong>
See a slightly modified version of HashSet&apos;s <code>add()</code>&apos;s Javadoc below.
Apply the category/partition method. What is <strong>the minimal and most suitable partitions</strong> for the <code>e</code> input parameter? </p>
<pre><code class="lang-java"><span class="hljs-comment">/**
 * Adds the specified element to this set if it 
 * is not already present.
 * If this set already contains the element, 
 * the call leaves the set unchanged
 * and returns false.
 *
 * If the specified element is NULL, the call leaves the
 * set unchanged and returns false.
 *
 * <span class="hljs-doctag">@param</span> e element to be added to this set
 * <span class="hljs-doctag">@return</span> true if this set did not already contain 
 *   the specified element
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>{
    <span class="hljs-comment">// implementation here</span>
}
</code></pre>
<p><strong>Exercise 6.</strong>
Which of the following statements <strong>is false</strong> about applying the category/partition method in method below?</p>
<pre><code class="lang-java"><span class="hljs-comment">/**
 * Puts the supplied value into the Map, 
 * mapped by the supplied key.
 * If the key is already on the map, its
 * value will be replaced by the new value.
 *
 * <span class="hljs-doctag">NOTE:</span> Nulls are not accepted as keys; 
 *  a RuntimeException is thrown when key is null.
 *
 * <span class="hljs-doctag">@param</span> key the key used to locate the value
 * <span class="hljs-doctag">@param</span> value the value to be stored in the HashMap
 * <span class="hljs-doctag">@return</span> the prior mapping of the key, 
 *  or null if there was none.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>{
  <span class="hljs-comment">// implementation here</span>
}
</code></pre>
<ol>
<li><p>The specification does not specify any details about the <code>value</code> input parameter, and thus, experience should be used to partition it, e.g., <code>value</code> being null and not null.</p>
</li>
<li><p>The number of tests generated by the category/partition method can grow quickly, as the chosen partitions for each category are later combined one-by-one. This is not a practical problem to the <code>put()</code> method because the number of categories and their partitions is small.</p>
</li>
<li><p>In an object-oriented language, besides using the method&apos;s input parameters to explore partitions, we should also consider the internal state of the object (i.e., the class&apos;s attributes), as it can also affect the behaviour of the method.</p>
</li>
<li><p>With the information in hands, it is not possible to perform the category/partition method, as the source code is required for the last step of the category/partition method: adding constraints.</p>
</li>
</ol>
<p><strong>Exercise 7.</strong>
With a <code>find</code> program that finds occurrences of a pattern in a file, the program has the following syntax:</p>
<pre><code>find &lt;pattern&gt; &lt;file&gt;
</code></pre><p>A tester, after reading the specs and following the Category-Partition method, devised the following test specification:</p>
<ul>
<li>Pattern size: empty, single character, many characters, longer than any line in the file.</li>
<li>Quoting: pattern is quoted, pattern is not quoted, pattern is improperly quoted.</li>
<li>File name: good file name, no file name with this name, omitted.</li>
<li>Occurrences in the file: none, exactly one, more than one.</li>
<li>Occurrences in a single line, assuming line contains the pattern: one, more than one.</li>
</ul>
<p>However, the number of combinations is too high now. What actions could we take to reduce the number of combinations?</p>
<h2 id="references">References</h2>
<ul>
<li><p>Graham, D., Van Veenendaal, E., &amp; Evans, I. (2008). Foundations of software testing: ISTQB certification. Cengage Learning EMEA. Chapter 4.</p>
</li>
<li><p>Pezz&#xE8;, M., &amp; Young, M. (2008). Software testing and analysis: process, principles, and techniques. John Wiley &amp; Sons. Chapter 10.</p>
</li>
<li><p>Ostrand, T. J., &amp; Balcer, M. J. (1988). The category-partition method for specifying and generating functional tests. Communications of the ACM, 31(6), 676-686.</p>
</li>
<li><p>Pacheco, C., &amp; Ernst, M. D. (2007, October). Randoop: feedback-directed random testing for Java. In Companion to the 22nd ACM SIGPLAN conference on Object-oriented programming systems and applications companion (pp. 815-816).</p>
</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Testing techniques">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="boundary-testing.html" class="navigation navigation-next " aria-label="Next page: Boundary testing">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Specification-based testing","level":"3.1.1","depth":2,"next":{"title":"Boundary testing","level":"3.1.2","depth":2,"path":"chapters/testing-techniques/boundary-testing.md","ref":"chapters/testing-techniques/boundary-testing.md","articles":[]},"previous":{"title":"Testing techniques","level":"3.1","depth":1,"path":"chapters/testing-techniques/README.md","ref":"chapters/testing-techniques/README.md","articles":[{"title":"Specification-based testing","level":"3.1.1","depth":2,"path":"chapters/testing-techniques/specification-based-testing.md","ref":"chapters/testing-techniques/specification-based-testing.md","articles":[]},{"title":"Boundary testing","level":"3.1.2","depth":2,"path":"chapters/testing-techniques/boundary-testing.md","ref":"chapters/testing-techniques/boundary-testing.md","articles":[]},{"title":"Structural-based testing","level":"3.1.3","depth":2,"path":"chapters/testing-techniques/structural-testing.md","ref":"chapters/testing-techniques/structural-testing.md","articles":[]},{"title":"Model-based testing","level":"3.1.4","depth":2,"path":"chapters/testing-techniques/model-based-testing.md","ref":"chapters/testing-techniques/model-based-testing.md","articles":[]},{"title":"Design-by-contracts","level":"3.1.5","depth":2,"path":"chapters/testing-techniques/design-by-contracts.md","ref":"chapters/testing-techniques/design-by-contracts.md","articles":[]},{"title":"Property-based testing","level":"3.1.6","depth":2,"path":"chapters/testing-techniques/property-based-testing.md","ref":"chapters/testing-techniques/property-based-testing.md","articles":[]}]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["hints","katex","ga","page-toc-button","splitter","back-to-top-button","chapter-fold"],"pluginsConfig":{"chapter-fold":{},"splitter":{},"search":{},"hints":{"danger":"fa fa-exclamation-circle","info":"fa fa-info-circle","tip":"fa fa-mortar-board","working":"fa fa-wrench"},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"katex":{},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"page-toc-button":{"maxTocDepth":2,"minTocSize":2},"back-to-top-button":{},"ga":{"configuration":"auto","token":"UA-154019382-1"},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"chapters/testing-techniques/specification-based-testing.md","mtime":"2020-04-06T03:15:15.315Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-04-09T18:42:34.468Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-ga/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-page-toc-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-splitter/splitter.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-chapter-fold/chapter-fold.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

